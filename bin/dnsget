#!/usr/bin/env python
#
# This file is a part of DNSViz, a tool suite for DNS/DNSSEC monitoring,
# analysis, and visualization.
# Created by Casey Deccio (casey@deccio.net)
#
# Copyright 2014-2015 VeriSign, Inc.
# 
# DNSViz is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# DNSViz is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

import codecs
import collections
import getopt
import json
import logging
import sys
import multiprocessing
import multiprocessing.managers
import threading
import time

import dns.exception, dns.name

from dnsviz.analysis import Analyst, OnlineDomainNameAnalysis, get_client_addresses, NetworkConnectivityException, resolver
import dnsviz.format as fmt
from dnsviz.ipaddr import IPAddr

logger = logging.getLogger('dnsviz.analysis.online')

#XXX this is a hack required for inter-process sharing of dns.name.Name
# instances using multiprocess
def _setattr_dummy(self, name, value):
    return super(dns.name.Name, self).__setattr__(name, value)
dns.name.Name.__setattr__ = _setattr_dummy

def _analyze((cls, name, dlv_domain, client_ipv4, client_ipv6, ceiling, explicit_delegations, cache, cache_level, cache_lock)):
    if ceiling is not None and name.is_subdomain(ceiling):
        c = ceiling
    else:
        c = name
    try:
        a = cls(name, dlv_domain=dlv_domain, client_ipv4=client_ipv4, client_ipv6=client_ipv6, ceiling=c, explicit_delegations=explicit_delegations, analysis_cache=cache, cache_level=cache_level, analysis_cache_lock=cache_lock)
        return a.analyze()
    except:
        logger.exception('Error analyzing %s' % name.canonicalize().to_text())

class BulkAnalyst(object):
    analyst_cls = Analyst

    def __init__(self, ceiling, cache_level, explicit_delegations, dlv_domain):
        self.client_ipv4, self.client_ipv6 = get_client_addresses()
        if self.client_ipv4 is None and self.client_ipv6 is None:
            raise NetworkConnectivityException('No network interfaces available for analysis!')
        self.ceiling = ceiling
        self.cache_level = cache_level
        self.explicit_delegations = explicit_delegations
        self.dlv_domain = dlv_domain

        self.cache = {}
        self.cache_lock = threading.Lock()

    def _name_to_args_iter(self, names):
        for name in names:
            yield (self.analyst_cls, name, self.dlv_domain, self.client_ipv4, self.client_ipv6, self.ceiling, self.explicit_delegations, self.cache, self.cache_level, self.cache_lock)

    def analyze(self, names, flush_func=None):
        name_objs = []
        for args in self._name_to_args_iter(names):
            name_obj = _analyze(args)
            if flush_func is not None:
                flush_func(name_obj)
            else:
                name_objs.append(name_obj)
        return name_objs

class MultiProcessAnalyst(Analyst):
    analysis_model = OnlineDomainNameAnalysis

    def _finalize_analysis_proper(self, name_obj):
        self.analysis_cache[name_obj.name] = name_obj
        super(MultiProcessAnalyst, self)._finalize_analysis_proper(name_obj)

    def _finalize_analysis_all(self, name_obj):
        self.analysis_cache[name_obj.name] = name_obj
        super(MultiProcessAnalyst, self)._finalize_analysis_all(name_obj)

    def refresh_dependency_references(self, name_obj, trace=None):
        if trace is None:
            trace = []

        if name_obj.name in trace:
            return

        if name_obj.parent is not None:
            self.refresh_dependency_references(name_obj.parent, trace+[name_obj.name])
        if name_obj.dlv_parent is not None:
            self.refresh_dependency_references(name_obj.dlv_parent, trace+[name_obj.name])

        # loop until all deps have been added
        for cname in name_obj.cname_targets:
            for target in name_obj.cname_targets[cname]:
                while name_obj.cname_targets[cname][target] is None:
                    try:
                        name_obj.cname_targets[cname][target] = self.analysis_cache[target]
                    except KeyError:
                        time.sleep(1)
                self.refresh_dependency_references(name_obj.cname_targets[cname][target], trace+[name_obj.name])
        for signer in name_obj.external_signers:
            while name_obj.external_signers[signer] is None:
                try:
                    name_obj.external_signers[signer] = self.analysis_cache[signer]
                except KeyError:
                    time.sleep(1)
            self.refresh_dependency_references(name_obj.external_signers[signer], trace+[name_obj.name])
        if self.follow_ns:
            for ns in name_obj.ns_dependencies:
                while name_obj.ns_dependencies[ns] is None:
                    try:
                        name_obj.ns_dependencies[ns] = self.analysis_cache[ns]
                    except KeyError:
                        time.sleep(1)
                self.refresh_dependency_references(name_obj.ns_dependencies[ns], trace+[name_obj.name])

    def analyze(self):
        name_obj = super(MultiProcessAnalyst, self).analyze()
        if not self.trace:
            self.refresh_dependency_references(name_obj)
        return name_obj

class ParallelAnalyst(BulkAnalyst):
    analyst_cls = MultiProcessAnalyst

    def __init__(self, ceiling, cache_level, explicit_delegations, dlv_domain, processes):
        super(ParallelAnalyst, self).__init__(ceiling, cache_level, explicit_delegations, dlv_domain)
        self.manager = multiprocessing.managers.SyncManager()
        self.manager.start()

        self.processes = processes

        self.cache = self.manager.dict()
        self.cache_lock = self.manager.Lock()

    def analyze(self, names, flush_func=None):

        pool = multiprocessing.Pool(self.processes)
        try:
            return pool.map(_analyze, self._name_to_args_iter(names))
        except KeyboardInterrupt:
            pool.terminate()
        else:
            pool.close()

        pool.join()

        return None

def usage(err=None):
    if err is not None:
        err += '\n\n'
    else:
        err = ''
    sys.stderr.write('''%sUsage: %s [ options ] ( -f <filename> | <domain name> [... ] )
Options:
    -f <filename>  - read names from a file (one name per line), instead of
                     from command line.
    -d <level>     - set debug level to a value from 0 to 3, with increasing
                     verbosity (default: 2 or INFO).
    -l <dlv>       - use dlv as a domain for DNSSEC look-aside validation.
    -r <filename>  - read analysis from a file, instead of querying servers
                     (use "-" for stdin).
    -t <threads>   - use multiple threads for analysis.
    -a <ancestor>  - analyze ancestry of name through specified ancestor,
                     instead of just name itself (use "-a ." or full ancestral
                     analysis) (default: analyze only the name itself).
    -x <domain>:<name>=<addr>(,<name>=<addr>[...])
                   - set explicit delegation for <domain>, using servers with
                     specified names (<name>) and addresses (<addr>).  This option
                     may be used multiple times for different domains or
                     servers.  Note that the names are simply for
                     identification, and it is not necessary for the names to
                     resolve to the corresponding address (or resolve at all
                     for that matter).
    -p             - make json output pretty instead of minimal.
    -o <filename>  - write the analysis to file <filename> instead of to
                     stdout, which is the default.
''' % (err, sys.argv[0]))

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'f:d:l:c:r:t:po:a:x:F')
    except getopt.GetoptError, e:
        usage(str(e))
        sys.exit(1)

    # get all the -x options
    explicit_delegations = {}
    for opt, arg in opts:
        if opt == '-x':
            try:
                domain, mappings = arg.split(':', 1)
            except ValueError:
                usage('Incorrect usage of -x option: "%s"' % arg)
                sys.exit(1)
            try:
                domain = dns.name.from_text(domain)
            except dns.exception.DNSException:
                usage('The domain name was invalid: "%s"' % domain)
                sys.exit(1)
            if not mappings:
                usage('Incorrect usage of -x option: "%s"' % arg)
                sys.exit(1)
            mappings = mappings.split(',')
            if domain not in explicit_delegations:
                explicit_delegations[domain] = set()
            for mapping in mappings:
                try:
                    name, addr = mapping.split('=')
                except ValueError:
                    usage('Incorrect usage of -x option: "%s"' % arg)
                    sys.exit(1)
                if addr[0] == '[' and addr[-1] == ']':
                    addr = addr[1:-1]
                try:
                    name = dns.name.from_text(name)
                except dns.exception.DNSException:
                    usage('The domain name was invalid: "%s"' % name)
                    sys.exit(1)
                try:
                    addr = IPAddr(addr)
                except ValueError:
                    usage('The IP address was invalid: "%s"' % addr)
                    sys.exit(1)
                explicit_delegations[domain].add((name, addr))

    opts = dict(opts)
    if not ('-f' in opts or args):
        usage('Either -f must be used or domain names must be supplied as command line arguments.')
        sys.exit(1)
    if '-f' in opts and args:
        usage('If -f is used, then domain names may not supplied as command line arguments.')
        sys.exit(1)

    if '-a' in opts:
        try:
            ceiling = dns.name.from_text(opts['-a'])
        except dns.exception.DNSException:
            usage('The domain name was invalid: "%s"' % opts['-a'])
            sys.exit(1)
    else:
        ceiling = None

    if '-l' in opts:
        try:
            dlv_domain = dns.name.from_text(opts['-l'])
        except dns.exception.DNSException:
            usage('The domain name was invalid: "%s"' % opts['-l'])
    else:
        dlv_domain = None

    # the following option is not documented in usage, as they don't
    # apply to most users
    try:
        cache_level = int(opts['-c'])
    except (KeyError, ValueError):
        cache_level = None

    try:
        processes = int(opts.get('-t', 1))
    except ValueError:
        usage('The number of threads used must be greater than 0.')
        sys.exit(1)
    if processes < 1:
        usage('The number of threads used must be greater than 0.')
        sys.exit(1)

    try:
        val = int(opts.get('-d', 2))
    except ValueError:
        usage('The debug value must be an integer between 0 and 3.')
        sys.exit(1)
    if val < 0 or val > 3:
        usage('The debug value must be an integer between 0 and 3.')
        sys.exit(1)

    if val > 2:
        debug_level = logging.DEBUG
    elif val > 1:
        debug_level = logging.INFO
    elif val > 0:
        debug_level = logging.WARNING
    else:
        debug_level = logging.ERROR
    handler = logging.StreamHandler()
    handler.setLevel(debug_level)
    logger.addHandler(handler)
    logger.setLevel(debug_level)

    names = []
    if '-f' in opts:
        try:
            f = codecs.open(opts['-f'], 'r', 'utf-8')
        except IOError, e:
            logger.error('%s: "%s"' % (e.strerror, opts['-f']))
            sys.exit(2)
        for line in f:
            name = line.strip()
            try:
                name = dns.name.from_unicode(name)
            except UnicodeDecodeError, e:
                logger.error('%s: "%s"' % (e, name))
            except dns.exception.DNSException:
                logger.error('The domain name was invalid: "%s"' % name)
            else:
                names.append(name)
        f.close()
    else:
        for name in args:
            try:
                name = dns.name.from_text(name)
            except dns.exception.DNSException:
                logger.error('The domain name was invalid: "%s"' % name)
            else:
                names.append(name)

    if '-p' in opts:
        kwargs = { 'indent': 4, 'separators': (',', ': ') }
    else:
        kwargs = {}

    if '-o' not in opts or opts['-o'] == '-':
        fh = sys.stdout
    else:
        try:
            fh = open(opts['-o'], 'w')
        except IOError, e:
            logger.error('%s: "%s"' % (e.strerror, opts['-o']))
            sys.exit(2)

    def _flush(name_obj):
        d = collections.OrderedDict()
        name_obj.serialize(d)
        s = json.dumps(d, **kwargs)
        lindex = s.index('{')
        rindex = s.rindex('}')
        fh.write(s[lindex+1:rindex]+',')

    flush = '-F' in opts

    name_objs = []
    if '-r' in opts:
        if opts['-r'] == '-':
            analysis_str = sys.stdin.read()
        else:
            try:
                analysis_str = open(opts['-r']).read()
            except IOError, e:
                logger.error('%s: "%s"' % (e.strerror, opts['-r']))
                sys.exit(2)
        try:
            analysis_structured = json.loads(analysis_str)
        except ValueError:
            logger.error('There was an error parsing the json input: "%s"' % opts['-r'])
            sys.exit(2)
        for name in names:
            name_objs.append(OnlineDomainNameAnalysis.deserialize(name, analysis_structured))
    else:
        if '-t' in opts:
            a = ParallelAnalyst(ceiling, cache_level, explicit_delegations, dlv_domain, processes)
        else:
            a = BulkAnalyst(ceiling, cache_level, explicit_delegations, dlv_domain)
            if flush:
                fh.write('{')
                a.analyze(names, _flush)
                fh.write('"_last._dnsviz":null}')
                sys.exit(0)

        name_objs = a.analyze(names)

    d = collections.OrderedDict()
    for name_obj in name_objs:
        if name_obj is None:
            continue
        name_obj.serialize(d)

    fh.write(json.dumps(d, **kwargs))

if __name__ == "__main__":
    main()
